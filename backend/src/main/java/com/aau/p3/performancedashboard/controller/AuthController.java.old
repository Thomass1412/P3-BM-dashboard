package com.aau.p3.performancedashboard.controller;

import java.util.LinkedList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import jakarta.validation.Valid;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.aau.p3.performancedashboard.model.ERole;
import com.aau.p3.performancedashboard.model.User;
import com.aau.p3.performancedashboard.payload.request.LoginRequest;
import com.aau.p3.performancedashboard.payload.request.SignupRequest;
import com.aau.p3.performancedashboard.payload.response.MessageResponse;
import com.aau.p3.performancedashboard.repository.UserRepository;
import com.aau.p3.performancedashboard.security.jwt.JwtUtils;
import com.aau.p3.performancedashboard.service.UserDetailsImpl;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller for handling authentication requests.
 * Provides endpoints for user login and signup.
 */
@Tag(name = "Authentication", description = "Authentication Management APIs")
@RestController
@RequestMapping("/auth")
public class AuthController {

  private static final Logger logger = LogManager.getLogger(AuthController.class);

  // Dependencies
  private final AuthenticationManager authenticationManager;
  private final UserRepository userRepository;
  private final PasswordEncoder encoder;
  private final JwtUtils jwtUtils;

  // Constructor injection
  @Autowired
  public AuthController(AuthenticationManager authenticationManager, UserRepository userRepository, PasswordEncoder encoder, JwtUtils jwtUtils) {
      this.authenticationManager = authenticationManager;
      this.userRepository = userRepository;
      this.encoder = encoder;
      this.jwtUtils = jwtUtils;
  }

  /**
   * Authenticates a user.
   * 
   * @param loginRequest The request body containing the username and password.
   * @return A Mono of ResponseEntity<String> representing the authentication result.
   */
  @Operation(summary = "Authenticate a user", description = "The request body must include a username and a password.")
  @ApiResponses({
      @ApiResponse(responseCode = "200", description = "Successfully authenticated user"),
      @ApiResponse(responseCode = "400", description = "Bad Request"),
      @ApiResponse(responseCode = "500", description = "Internal Server Error")
  })
  @PostMapping(path = "/signin", consumes = "application/json", produces = "application/json")
  public Mono<ResponseEntity<MessageResponse>> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {

    // Authenticate the user
    logger.debug("Authenticating user: " + loginRequest.getUsername());
    UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword());
    Authentication authentication = authenticationManager.authenticate(authenticationToken);

    logger.debug("Authentication request: " + authentication.toString()); 

    // Set the authentication in the security context
    SecurityContextHolder.getContext().setAuthentication(authentication);
    logger.debug("Security context: " + SecurityContextHolder.getContext().toString());

    // Generate JWT token
    UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
    logger.debug("User details: " + userDetails.toString());

    ResponseCookie jwtCookie = jwtUtils.generateJwtCookie(userDetails);
    logger.debug("JWT cookie: " + jwtCookie.toString());

    List<String> roles = userDetails.getAuthorities().stream()
        .map(item -> item.getAuthority())
        .peek(item -> logger.debug("Authority: " + item))
        .collect(Collectors.toList());

    logger.debug("Logging user in: " + userDetails.getUsername() + " with roles: ");
    roles.forEach(role -> logger.debug("Role: " + role));

    logger.debug("Successfully authenticated user");
    return Mono.just(ResponseEntity.ok()
        .header(HttpHeaders.SET_COOKIE, jwtCookie.toString())
        .body(new MessageResponse("Successfully authenticated user")));
  }

  /**
   * Registers a new user.
   *
   * @param signUpRequest the request body containing the user's information
   * @return a Mono of ResponseEntity containing a MessageResponse indicating the result of the registration
   */
  @Operation(summary = "Register a new user", description = "The request body must include a username, an email, a password and optionally a list of roles. If roles are not provided, agent role will be assigned by default.")
  @ApiResponses({
      @ApiResponse(responseCode = "200", description = "Successfully registered user"),
      @ApiResponse(responseCode = "400", description = "Bad Request"),
      @ApiResponse(responseCode = "500", description = "Internal Server Error")
  })
  @PostMapping("/signup")
  public Mono<ResponseEntity<MessageResponse>> registerUser(@Valid @RequestBody SignupRequest signUpRequest) {
    // Check if username or email already exists
    if (userRepository.existsByUsername(signUpRequest.getUsername()).block()) {
      return Mono.just(ResponseEntity.badRequest().body(new MessageResponse("Error: Username is already taken!")));
    }

    // Check if email already exists
    if (userRepository.existsByEmail(signUpRequest.getEmail()).block()) {
      return Mono.just(ResponseEntity
          .badRequest()
          .body(new MessageResponse("Error: Email is already in use!")));
    }

    // Create new user's account
    String id = UUID.randomUUID().toString();
    User user = new User(id, signUpRequest.getUsername(),
        signUpRequest.getEmail(),
        encoder.encode(signUpRequest.getPassword()));

    // Get the roles from the request body
    List<String> strRoles = signUpRequest.getRoles();

    List<String> roles = new LinkedList<>();

    if (strRoles == null) {
        roles.add(ERole.ROLE_AGENT.name());
    } else {
        strRoles.forEach(role -> {
            switch (role) {
                case "admin":
                    roles.add(ERole.ROLE_ADMIN.name());
                    break;
                case "supervisor":
                    roles.add(ERole.ROLE_SUPERVISOR.name());
                    break;
                case "tv":
                    roles.add(ERole.ROLE_TV.name());
                    break;
                default:
                    roles.add(ERole.ROLE_AGENT.name());
            }
        });
    }

    user.setRoles(roles);
    return userRepository.save(user)
        .map(savedUser -> ResponseEntity.ok(new MessageResponse("User registered successfully!")));
}

  /**
   * Retrieves all users.
   * 
   * @return a Flux of User objects representing all users.
   */
  @Operation(summary = "Retrieve all users", description = "The response object will contain a list of all users.")
  @GetMapping(path = "/users", produces = "application/json")
  public Flux<User> getAllUsers() {
    return userRepository.findAll();
  }
}


