package com.aau.p3.performancedashboard.service;

import org.bson.Document;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.core.ReactiveMongoOperations;
import org.springframework.data.mongodb.core.ReactiveMongoTemplate;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;

import com.aau.p3.performancedashboard.payload.request.CreateIntegrationRequest;
import com.aau.p3.performancedashboard.payload.response.IntegrationDataResponse;
import com.aau.p3.performancedashboard.converter.IntegrationDataConverter;
import com.aau.p3.performancedashboard.payload.request.CreateIntegrationDataRequest;
import com.mongodb.client.model.CreateCollectionOptions;
import com.mongodb.client.model.ValidationAction;
import com.mongodb.client.model.ValidationLevel;
import com.mongodb.client.model.ValidationOptions;
import com.mongodb.reactivestreams.client.MongoDatabase;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Service
public class IntegrationDataService {

	// Logger
	private static final Logger logger = LoggerFactory.getLogger(IntegrationDataService.class);

	// Dependencies
	private final IntegrationService integrationService;
	private final ReactiveMongoOperations mongoOperations;
	private final ReactiveMongoTemplate mongoTemplate;
	private final MongoDatabase mongoDatabase;

	// Constructor injection
	@Autowired
	public IntegrationDataService(IntegrationService integrationService, ReactiveMongoOperations mongoOperations,
			ReactiveMongoTemplate mongoTemplate, MongoDatabase mongoDatabase) {
		this.integrationService = integrationService;
		this.mongoOperations = mongoOperations;
		this.mongoTemplate = mongoTemplate;
		this.mongoDatabase = mongoDatabase;
	}

	/**
	 * Finds all integration data by integration ID and pageable.
	 *
	 * @param integrationId the ID of the integration
	 * @param pageable the pageable object for pagination
	 * @return a Mono of Page<IntegrationDataResponse> containing the integration data
	 */
	public Mono<Page<IntegrationDataResponse>> findAllBy(String integrationId, Pageable pageable) {
		return integrationService.findById(integrationId)
				.flatMap(integration -> {
					if (!integration.getType().equals("internal")) {
						return Mono.error(new IllegalArgumentException(
								"Integration with id '" + integrationId + "' is not internal."));
					} else {
						// Get the name of the data collection
						String dataCollection = integration.getDataCollection();

						// Create a query object with the provided pageable
						Query query = new Query().with(pageable);

						// Find the data and count the total number of elements
						Flux<IntegrationDataResponse> data = mongoTemplate.find(query, IntegrationDataResponse.class,
								dataCollection);
						Mono<Long> count = mongoTemplate.count(query, dataCollection);

						// Return a Mono emitting a Page of IntegrationDataResponse objects
						return data
								.collectList()
								.zipWith(count)
								.map(objects -> new PageImpl<>(objects.getT1(), pageable, objects.getT2()));
					}
				});
	}

	/**
	 * Creates a new MongoDB collection with a JSON schema derived from the provided
	 * {@link CreateIntegrationRequest}.
	 * The schema is generated by calling
	 * {@link CreateIntegrationRequest#generateSchema()}.
	 * If the schema generation is successful, a new collection is created with the
	 * generated schema.
	 * If the schema generation fails, an error is logged and a
	 * {@link RuntimeException} is propagated.
	 *
	 * @param integrationRequest the {@link CreateIntegrationRequest} from which to
	 *                           generate the schema and collection name.
	 * @return a {@link Mono<String>} that emits the name of the created collection
	 *         when the operation is successful.
	 *         The Mono completes empty if the operation fails.
	 * @throws RuntimeException if an error occurs while generating the schema.
	 */
	public Mono<String> createCollection(CreateIntegrationRequest integrationRequest) {
		return Mono.fromCallable(integrationRequest::generateSchema)
				.doOnSuccess(s -> logger
						.info("Created schema: " + s.toString() + " for collection: " + integrationRequest.getName()))
				.doOnError(
						e -> logger.error("Error creating schema for collection: " + integrationRequest.getName(), e))
				.onErrorResume(e -> Mono.error(
						new RuntimeException("Error creating schema: " + e.getMessage(), e)))
				.flatMap(schema -> {
					// Create a validation options object
					ValidationOptions validationOptions = new ValidationOptions()
							.validator(schema.toDocument())
							.validationLevel(ValidationLevel.STRICT)
							.validationAction(ValidationAction.ERROR);

					// Create a collection options object
					CreateCollectionOptions collectionOptions = new CreateCollectionOptions()
							.validationOptions(validationOptions);

					// Extract the collection name from the request
					String collectionName = integrationRequest.getName() + "_data";

					// Create the collection with the schema and return the collection name
					return Mono.from(mongoDatabase.createCollection(collectionName, collectionOptions))
							.doOnSuccess(collection -> logger.info("Created collection: " + collectionName))
							.thenReturn(collectionName);
				});
	}

	/**
	 * Saves integration data for a given integration ID.
	 *
	 * @param integrationId The ID of the integration.
	 * @param integrationDataRequest The request object containing the integration data to be saved.
	 * @return A Mono emitting the IntegrationDataResponse after saving the data.
	 */
	public Mono<IntegrationDataResponse> saveIntegrationData(String integrationId,
			CreateIntegrationDataRequest integrationDataRequest) {
		return integrationService.findById(integrationId)
				.flatMap(integration -> {
					if (!integration.getType().equals("internal")) {
						return Mono.error(new IllegalArgumentException(
								"Integration with id '" + integrationId + "' is not internal."));
					} else {
						// Convert the integration data request to a document ready to be inserted into
						// the database
						Document document = IntegrationDataConverter
								.convertCreateIntegrationDataRequestToDocument(integrationId, integrationDataRequest);

						// Insert a reference to the integration into the document
						document.put("integrationId", (String) integrationId);

						// Insert the document into the collection
						return mongoOperations.getCollection(integration.getDataCollection())
								.flatMap(collection -> Mono.from(collection.insertOne(document)))
								.doOnSuccess(result -> logger.info("Successfully saved: " + document.toJson()
										+ " to collection: " + integration.getDataCollection())) // Log the result
								.doOnError(error -> logger.error("Error saving: " + document.toJson()
										+ " to collection: " + integration.getDataCollection(), error)) // Log the error
								.flatMap(result -> Mono.just(
										IntegrationDataConverter.convertDocumentToIntegrationDataResponse(document)))
								.onErrorMap(ClassCastException.class, ex -> new RuntimeException(ex.getMessage(), ex))
								.doOnError(error -> logger.error(
										"Error converting document to IntegrationDataResponse: " + error.getMessage(),
										error)); // Log the error
					}
				});
	}

}
