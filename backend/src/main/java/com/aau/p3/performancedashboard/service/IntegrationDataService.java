package com.aau.p3.performancedashboard.service;

import org.bson.Document;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.core.ReactiveMongoOperations;
import org.springframework.stereotype.Service;

import com.aau.p3.performancedashboard.payload.request.CreateIntegrationRequest;
import com.aau.p3.performancedashboard.payload.response.IntegrationDataResponse;
import com.aau.p3.performancedashboard.converter.IntegrationDataConverter;
import com.aau.p3.performancedashboard.payload.request.CreateIntegrationDataRequest;
import com.mongodb.client.model.CreateCollectionOptions;
import com.mongodb.client.model.ValidationAction;
import com.mongodb.client.model.ValidationLevel;
import com.mongodb.client.model.ValidationOptions;
import com.mongodb.reactivestreams.client.MongoDatabase;

import reactor.core.publisher.Mono;

@Service
public class IntegrationDataService {
	
	// Logger
	private static final Logger logger = LoggerFactory.getLogger(IntegrationDataService.class);

	// Dependencies
	private final IntegrationService integrationService;
	private final ReactiveMongoOperations mongoOperations;
	private final MongoDatabase mongoDatabase;
	private final TestService integrationDataRepository;

	// Constructor injection
	@Autowired
	public IntegrationDataService(IntegrationService integrationService, ReactiveMongoOperations mongoOperations,
			MongoDatabase mongoDatabase, TestService integrationDataRepository) {
		this.integrationService = integrationService;
		this.mongoOperations = mongoOperations;
		this.mongoDatabase = mongoDatabase;
		this.integrationDataRepository = integrationDataRepository;
	}

	/**
	 * Retrieves a page of IntegrationDataResponse objects based on the provided
	 * integrationId and pageable parameters.
	 * 
	 * @param integrationId the ID of the integration
	 * @param pageable      the pageable object specifying the page number and size
	 * @return a Mono containing a Page of IntegrationDataResponse objects
	 */
	public Mono<Page<IntegrationDataResponse>> findAllBy(String integrationId, Pageable pageable) {
		return integrationService.findById(integrationId)
				.flatMap(integration -> {
					if (!integration.getType().equals("internal")) {
						return Mono.error(new IllegalArgumentException(
								"Integration with id '" + integrationId + "' is not internal."));
					} else {
						return integrationDataRepository.findAllBy(integrationId, pageable);
					}
				});
	}

	/**
	 * Creates a new MongoDB collection with a JSON schema derived from the provided
	 * {@link CreateIntegrationRequest}.
	 * The schema is generated by calling
	 * {@link CreateIntegrationRequest#generateSchema()}.
	 * If the schema generation is successful, a new collection is created with the
	 * generated schema.
	 * If the schema generation fails, an error is logged and a
	 * {@link RuntimeException} is propagated.
	 *
	 * @param integrationRequest the {@link CreateIntegrationRequest} from which to
	 *                           generate the schema and collection name.
	 * @return a {@link Mono<String>} that emits the name of the created collection
	 *         when the operation is successful.
	 *         The Mono completes empty if the operation fails.
	 * @throws RuntimeException if an error occurs while generating the schema.
	 */
	public Mono<String> createCollection(CreateIntegrationRequest integrationRequest) {
		return Mono.fromCallable(integrationRequest::generateSchema)
				.doOnSuccess(s -> logger
						.info("Created schema: " + s.toString() + " for collection: " + integrationRequest.getName()))
				.doOnError(
						e -> logger.error("Error creating schema for collection: " + integrationRequest.getName(), e))
				.onErrorResume(e -> Mono.error(
						new RuntimeException("Error creating schema: " + e.getMessage(), e)))
				.flatMap(schema -> {
					// Create a validation options object
					ValidationOptions validationOptions = new ValidationOptions()
							.validator(schema.toDocument())
							.validationLevel(ValidationLevel.STRICT)
							.validationAction(ValidationAction.ERROR);

					// Create a collection options object
					CreateCollectionOptions collectionOptions = new CreateCollectionOptions()
							.validationOptions(validationOptions);

					// Extract the collection name from the request
					String collectionName = integrationRequest.getName() + "_data";

					// Create the collection with the schema and return the collection name
					return Mono.from(mongoDatabase.createCollection(collectionName, collectionOptions))
							.doOnSuccess(collection -> logger.info("Created collection: " + collectionName))
							.thenReturn(collectionName);
				});
	}

	public Mono<IntegrationDataResponse> saveIntegrationData(String integrationId,
			CreateIntegrationDataRequest integrationDataRequest) {
		return integrationService.findById(integrationId)
				.flatMap(integration -> {
					if (!integration.getType().equals("internal")) {
						return Mono.error(new IllegalArgumentException(
								"Integration with id '" + integrationId + "' is not internal."));
					} else {
						// Convert the integration data request to a document ready to be inserted into
						// the database
						Document document = IntegrationDataConverter
								.convertCreateIntegrationDataRequestToDocument(integrationId, integrationDataRequest);

						// Insert a reference to the integration into the document
						document.put("integrationId", (String) integrationId);

						// Insert the document into the collection
						return mongoOperations.getCollection(integration.getDataCollection())
								.flatMap(collection -> Mono.from(collection.insertOne(document))) // Insert the document
																									// into the
																									// collection
								.doOnSuccess(result -> logger.info("Successfully saved: " + document.toJson()
										+ " to collection: " + integration.getDataCollection())) // Log the result
								.doOnError(error -> logger.error("Error saving: " + document.toJson()
										+ " to collection: " + integration.getDataCollection(), error)) // Log the error
								.flatMap(result -> Mono.just(
										IntegrationDataConverter.convertDocumentToIntegrationDataResponse(document))) // Convert
																														// the
																														// inserted
																														// document
																														// to
																														// an
																														// IntegrationDataResponse
								.onErrorMap(ClassCastException.class, ex -> new RuntimeException(ex.getMessage(), ex)) // Map
																														// the
																														// ClassCastException
																														// to
																														// a
																														// RuntimeException
								.doOnError(error -> logger.error(
										"Error converting document to IntegrationDataResponse: " + error.getMessage(),
										error)); // Log the error
					}
				});
	}
}
